<?php

require_once "PhpFrameworkZero/functions.php";
require_once "PhpFrameworkZero/PlainTextElement.php";
require_once "PhpFrameworkZero/ExpressionElement.php";
require_once "PhpFrameworkZero/EchoElement.php";
require_once "PhpFrameworkZero/IfElement.php";

/**
 * Parses and executes html templates.
 *
 * @property array $context To be filled with the variables for the template before execution
 * @method execute Prints the result
 */
class Template {
	/**
	 * @var array $context array of variables that will be passed to the template on execution.
	 */
	public $context;
	private $components = array();
	/**
	 * Constructs Template object.
	 *
	 * Reads template and stores it as an array of TemplateElement objects.
	 * @param string $name The name of the template,
	 * so path should be /app/templates/$name for each app.
	 * @param array $context Optional, {@link $context}.
	 */
	function __construct($name, $context = array()) {
		$file = $this->getTemplateFile($name);
		$this->context = $context;

		$parts = multiexplode(["[[","]]"], $file); // Storing the exploded array, $i%2 = is plaintext
		for ($i = 1; $i < count($parts)/2; $i+=2) $parts[$i] = trim($parts[$i]);

		$this->components = $this->parseCommands($parts);
	}

	/**
	 * Parse an array of template commands.
	 *
	 * Iterates through the template and parses each element until either we run out of
	 * text or one of them parses to the exit value specified.
	 * @param array $array The array to iterate on
	 * @param object $exitOn Constant, the loop will be terminated once a command parses to this value.
	 * @param int $i The index to start from. Do not change the array. If you do so,
	 * angry russians riding on bears will visit you tonight.
	 */
	private function parseCommands($array, $exitOn = null, &$i = 0) {
		$components = array();
		for (; $i < count($array); $i++) {
			$newcomp = $this->parseElement($array, $i);
			if ($newcomp == $exitOn) { break; }
			array_push( $components, $newcomp );
		}
		return $components;
	}

	/**
	 * Parse a single element.
	 *
	 * Parses a single template component, like a piece of text, a statement or an if block.
	 * May increase offset if the component spans multiple commands. (hence it's a reference argument)
	 * @param array $array Array, generated by breaking the file up at delimiters.
	 * @param int $offset Reference, the index to digest first, will change to the last index digested.
	 * @return TemplateElement {@link TemplateElement}
	 */
	private function parseElement($array, &$offset) {
		$element = null;
		// Every second index starting from the 0th element must be plaintext
		if ($offset%2 == 0) {
			// Getting the entire plain text that we want to see in the result unchanged
			$text = $array[$offset];
			// And turning it into a TemplateElement, because serialization
			$element = new PlainTextElement($text);
		}
		// For anything else
		else {
			$array[$offset] = trim($array[$offset]);
			// Recognizing echo statements
			if (startswith("echo ", $array[$offset])) {
				// Getting the part after echo and turning it into an expression
				$string = substr($array[$offset], 5);
				$expression = new ExpressionElement($string);
				// Creating the echo element
				$element = new EchoElement($expression);
			}
			// Recognizing if statements
			else if ( startswith("if ", $array[$offset]) ) {
				// Gettihg the part after if (the condition) and turning it into an expression
				$expstr = substr($array[$offset], 3);
				$expression = new ExpressionElement($expstr);
				// Parsing the block, which ends at the first endif
				// (recursion ensures that it's not another if's endif)
				++$offset;
				$block = $this->parseCommands($array, IfElement::END, $offset);
				// Creating the if element
				$element = new IfElement($expression, $block);
			}
			// Recognizing endif statements, no further logic required
			else if ( "endif" == $array[$offset] ) $element = IfElement::END;
			else if ( "else" == $array[$offset] ) $element = new ElseElement();
			else if ( startswith("elsif ", $array[$offset]) ) {
				// Gettihg the part after elsif (the condition) and turning it into an expression
				$expstr = substr($array[$offset], 6);
				$expression = new ExpressionElement($expstr);
				// Creating the elsif element
				$element = new ElsifElement($expression);
			}
			else throw new Exception("Unknown block type: [".$array[$offset]."]");
		}
		return $element;
	}

	private function getTemplateFile($name) {
		foreach (scandir(".") as $item) {
			$path = "./".$item."/templates/".$name;
			if (is_file($path))
				return file_get_contents($path);
		}
		throw new Exception("Couldn't find template [".$name."]");
	}

	/**
	 * Executes the template to the output buffer
	 *
	 * Renders the template with the context.
	 * @param array $context will OVERRIDE existing context.
	 */
	public function execute($context = null) {
		if ($context == null) $context = $this->context;
		foreach ($this->components as $component) {
			echo $component->execute($context);
		}
	}
}

?>
